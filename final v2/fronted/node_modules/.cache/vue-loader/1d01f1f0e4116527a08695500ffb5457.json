{"remainingRequest":"/Users/lrlbabee/Desktop/CUC/大三下/结课/数据可视化/doob-business-and-consulting-vue-js-template/doob/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/lrlbabee/Desktop/CUC/大三下/结课/数据可视化/doob-business-and-consulting-vue-js-template/doob/node_modules/vue-visibility-sensor/visibility-sensor.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/lrlbabee/Desktop/CUC/大三下/结课/数据可视化/doob-business-and-consulting-vue-js-template/doob/node_modules/vue-visibility-sensor/visibility-sensor.vue","mtime":1686702248655},{"path":"/Users/lrlbabee/Desktop/CUC/大三下/结课/数据可视化/doob-business-and-consulting-vue-js-template/doob/node_modules/cache-loader/dist/cjs.js","mtime":1686702247989},{"path":"/Users/lrlbabee/Desktop/CUC/大三下/结课/数据可视化/doob-business-and-consulting-vue-js-template/doob/node_modules/babel-loader/lib/index.js","mtime":1686702243633},{"path":"/Users/lrlbabee/Desktop/CUC/大三下/结课/数据可视化/doob-business-and-consulting-vue-js-template/doob/node_modules/cache-loader/dist/cjs.js","mtime":1686702247989},{"path":"/Users/lrlbabee/Desktop/CUC/大三下/结课/数据可视化/doob-business-and-consulting-vue-js-template/doob/node_modules/vue-loader/lib/index.js","mtime":1686702243693}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiAgJ3VzZSBzdHJpY3QnOwoKICAvKioKICAgKiBAcGFyYW0ge3sgdG9wOiBOdW1iZXIsIGxlZnQ6IE51bWJlciwgYm90dG9tOiBOdW1iZXIsIHJpZ2h0OiBOdW1iZXIsIHdpZHRoOiBOdW1iZXIsIGhlaWdodDogTnVtYmVyIH19IHJlY3QKICAgKiBAcmV0dXJucyB7eyB0b3A6IE51bWJlciwgbGVmdDogTnVtYmVyLCBib3R0b206IE51bWJlciwgcmlnaHQ6IE51bWJlciwgd2lkdGg6IE51bWJlciwgaGVpZ2h0OiBOdW1iZXIgfX0KICAgKiAqLwogIGZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QgKHJlY3QpIHsKICAgIGlmIChyZWN0LndpZHRoID09PSB1bmRlZmluZWQpIHsKICAgICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7CiAgICB9CgogICAgaWYgKHJlY3QuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsKICAgICAgcmVjdC5oZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wOwogICAgfQoKICAgIHJldHVybiByZWN0OwogIH0KCiAgLyoqCiAgICogQHBhcmFtIHt7IHRvcDogTnVtYmVyLCBsZWZ0OiBOdW1iZXIsIGJvdHRvbTogTnVtYmVyLCByaWdodDogTnVtYmVyIH19IHJlY3QKICAgKiBAcmV0dXJucyB7eyB0b3A6IE51bWJlciwgbGVmdDogTnVtYmVyLCBib3R0b206IE51bWJlciwgcmlnaHQ6IE51bWJlciB9fQogICAqICovCiAgZnVuY3Rpb24gcm91bmRSZWN0RG93biAocmVjdCkgewogICAgcmV0dXJuIHsKICAgICAgdG9wOiBNYXRoLmZsb29yKHJlY3QudG9wKSwKICAgICAgbGVmdDogTWF0aC5mbG9vcihyZWN0LmxlZnQpLAogICAgICBib3R0b206IE1hdGguZmxvb3IocmVjdC5ib3R0b20pLAogICAgICByaWdodDogTWF0aC5mbG9vcihyZWN0LnJpZ2h0KQogICAgfTsKICB9CgogIGV4cG9ydCBkZWZhdWx0IHsKICAgIG5hbWU6ICdWaXNpYmlsaXR5U2Vuc29yJywKICAgIHByb3BzOiB7CiAgICAgIGFjdGl2ZTogewogICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgZGVmYXVsdDogdHJ1ZQogICAgICB9LAogICAgICBwYXJ0aWFsVmlzaWJpbGl0eTogewogICAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLAogICAgICAgIGRlZmF1bHQ6IGZhbHNlLAogICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHYpIHsKICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZih2KSA+IC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgbWluVG9wVmFsdWU6IHsKICAgICAgICB0eXBlOiBOdW1iZXIsCiAgICAgICAgZGVmYXVsdDogMAogICAgICB9LAogICAgICBzY3JvbGxDaGVjazogewogICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgfSwKICAgICAgc2Nyb2xsRGVsYXk6IHsKICAgICAgICB0eXBlOiBOdW1iZXIsCiAgICAgICAgZGVmYXVsdDogMjUwCiAgICAgIH0sCiAgICAgIHNjcm9sbFRocm90dGxlOiB7CiAgICAgICAgdHlwZTogTnVtYmVyLAogICAgICAgIGRlZmF1bHQ6IC0xCiAgICAgIH0sCiAgICAgIHJlc2l6ZUNoZWNrOiB7CiAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICBkZWZhdWx0OiBmYWxzZQogICAgICB9LAogICAgICByZXNpemVEZWxheTogewogICAgICAgIHR5cGU6IE51bWJlciwKICAgICAgICBkZWZhdWx0OiAyNTAKICAgICAgfSwKICAgICAgcmVzaXplVGhyb3R0bGU6IHsKICAgICAgICB0eXBlOiBOdW1iZXIsCiAgICAgICAgZGVmYXVsdDogLTEKICAgICAgfSwKICAgICAgaW50ZXJ2YWxDaGVjazogewogICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgZGVmYXVsdDogdHJ1ZQogICAgICB9LAogICAgICBpbnRlcnZhbERlbGF5OiB7CiAgICAgICAgdHlwZTogTnVtYmVyLAogICAgICAgIGRlZmF1bHQ6IDEwMAogICAgICB9LAogICAgICBkZWxheWVkQ2FsbDogewogICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgfSwKICAgICAgb2Zmc2V0OiB7CiAgICAgICAgdHlwZTogT2JqZWN0LAogICAgICAgIGRlZmF1bHQ6ICgpID0+IHsKICAgICAgICB9CiAgICAgICAgLy8gc2hvdWxkIGJlCiAgICAgICAgLy8gewogICAgICAgIC8vICAgdG9wOiBOdW1iZXIsCiAgICAgICAgLy8gICBsZWZ0OiBOdW1iZXIsCiAgICAgICAgLy8gICByaWdodDogTnVtYmVyLAogICAgICAgIC8vICAgYm90dG9tOiBOdW1iZXIsCiAgICAgICAgLy8gfQogICAgICB9LAogICAgICBjb250YWlubWVudDogewogICAgICAgIGRlZmF1bHQ6IG51bGwKICAgICAgfQogICAgfSwKICAgIGRhdGEgKCkgewogICAgICByZXR1cm4gewogICAgICAgIGlzVmlzaWJsZTogbnVsbCwKICAgICAgICB2aXNpYmlsaXR5UmVjdDoge30KICAgICAgfTsKICAgIH0sCiAgICBtb3VudGVkICgpIHsKICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7CiAgICAgICAgdGhpcy5zdGFydFdhdGNoaW5nKCk7CiAgICAgIH0KICAgIH0sCiAgICB1cGRhdGVkICgpIHsKCiAgICB9LAogICAgYmVmb3JlRGVzdHJveSAoKSB7CiAgICAgIHRoaXMuc3RvcFdhdGNoaW5nKCk7CiAgICB9LAogICAgbWV0aG9kczogewogICAgICBnZXRDb250YWluZXIgKCkgewogICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5tZW50IHx8IHdpbmRvdzsKICAgICAgfSwKICAgICAgYWRkRXZlbnRMaXN0ZW5lciAodGFyZ2V0LCBldmVudCwgZGVsYXksIHRocm90dGxlKSB7CiAgICAgICAgaWYgKCF0aGlzLmRlYm91bmNlQ2hlY2spIHsKICAgICAgICAgIHRoaXMuZGVib3VuY2VDaGVjayA9IHt9OwogICAgICAgIH0KICAgICAgICBsZXQgdGltZW91dDsKICAgICAgICBsZXQgZm47CiAgICAgICAgY29uc3QgbGF0ZXIgPSAoKSA9PiB7CiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDsKICAgICAgICAgIHRoaXMuY2hlY2soKTsKICAgICAgICB9OwoKICAgICAgICBpZiAodGhyb3R0bGUgPiAtMSkgewogICAgICAgICAgZm4gPSAoKSA9PiB7CiAgICAgICAgICAgIGlmICghdGltZW91dCkgewogICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB0aHJvdHRsZSB8fCAwKTsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZm4gPSAoKSA9PiB7CiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTsKICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIGRlbGF5IHx8IDApOwogICAgICAgICAgfTsKICAgICAgICB9CgogICAgICAgIGNvbnN0IGluZm8gPSB7CiAgICAgICAgICB0YXJnZXQsCiAgICAgICAgICBmbiwKICAgICAgICAgIGdldExhc3RUaW1lb3V0OiAoKSA9PiB0aW1lb3V0CiAgICAgICAgfTsKCiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGluZm8uZm4pOwogICAgICAgIHRoaXMuZGVib3VuY2VDaGVja1tldmVudF0gPSBpbmZvOwogICAgICB9LAogICAgICBzdGFydFdhdGNoaW5nICgpIHsKICAgICAgICBpZiAodGhpcy5kZWJvdW5jZUNoZWNrIHx8IHRoaXMuaW50ZXJ2YWwpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIGlmICh0aGlzLmludGVydmFsQ2hlY2spIHsKICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmNoZWNrKCksIHRoaXMuaW50ZXJ2YWxEZWxheSk7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5zY3JvbGxDaGVjaykgewogICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKAogICAgICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLAogICAgICAgICAgICAnc2Nyb2xsJywKICAgICAgICAgICAgdGhpcy5zY3JvbGxEZWxheSwKICAgICAgICAgICAgdGhpcy5zY3JvbGxUaHJvdHRsZQogICAgICAgICAgKTsKICAgICAgICB9CgogICAgICAgIGlmICh0aGlzLnJlc2l6ZUNoZWNrKSB7CiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoCiAgICAgICAgICAgIHdpbmRvdywKICAgICAgICAgICAgJ3Jlc2l6ZScsCiAgICAgICAgICAgIHRoaXMucmVzaXplRGVsYXksCiAgICAgICAgICAgIHRoaXMucmVzaXplVGhyb3R0bGUKICAgICAgICAgICk7CiAgICAgICAgfQoKICAgICAgICAhdGhpcy5kZWxheWVkQ2FsbCAmJiB0aGlzLmNoZWNrKCk7CiAgICAgIH0sCiAgICAgIHN0b3BXYXRjaGluZyAoKSB7CiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VDaGVjaykgewogICAgICAgICAgLy8gY2xlYW4gdXAgZXZlbnQgbGlzdGVuZXJzIGFuZCB0aGVpciBkZWJvdW5jZSBjYWxsZXJzCiAgICAgICAgICBmb3IgKGxldCBkZWJvdW5jZUV2ZW50IGluIHRoaXMuZGVib3VuY2VDaGVjaykgewogICAgICAgICAgICBpZiAodGhpcy5kZWJvdW5jZUNoZWNrLmhhc093blByb3BlcnR5KGRlYm91bmNlRXZlbnQpKSB7CiAgICAgICAgICAgICAgY29uc3QgZGVib3VuY2VJbmZvID0gdGhpcy5kZWJvdW5jZUNoZWNrW2RlYm91bmNlRXZlbnRdOwoKICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VJbmZvLmdldExhc3RUaW1lb3V0KCkpOwogICAgICAgICAgICAgIGRlYm91bmNlSW5mby50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigKICAgICAgICAgICAgICAgIGRlYm91bmNlRXZlbnQsCiAgICAgICAgICAgICAgICBkZWJvdW5jZUluZm8uZm4KICAgICAgICAgICAgICApOwoKICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlQ2hlY2tbZGVib3VuY2VFdmVudF0gPSBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuZGVib3VuY2VDaGVjayA9IG51bGw7CgogICAgICAgIGlmICh0aGlzLmludGVydmFsKSB7CiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpOwogICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IG51bGw7CiAgICAgICAgfQogICAgICB9LAogICAgICBjaGVjayAoKSB7CiAgICAgICAgY29uc3QgZWwgPSB0aGlzLiRlbDsKICAgICAgICBsZXQgcmVjdDsKICAgICAgICBsZXQgY29udGFpbm1lbnRSZWN0OwoKICAgICAgICBpZiAoIWVsKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICByZWN0ID0gbm9ybWFsaXplUmVjdChyb3VuZFJlY3REb3duKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSk7CgogICAgICAgIGlmICh0aGlzLmNvbnRhaW5tZW50KSB7CiAgICAgICAgICBjb25zdCBjb250YWlubWVudERPTVJlY3QgPSB0aGlzLmNvbnRhaW5tZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgICAgY29udGFpbm1lbnRSZWN0ID0gewogICAgICAgICAgICB0b3A6IGNvbnRhaW5tZW50RE9NUmVjdC50b3AsCiAgICAgICAgICAgIGxlZnQ6IGNvbnRhaW5tZW50RE9NUmVjdC5sZWZ0LAogICAgICAgICAgICBib3R0b206IGNvbnRhaW5tZW50RE9NUmVjdC5ib3R0b20sCiAgICAgICAgICAgIHJpZ2h0OiBjb250YWlubWVudERPTVJlY3QucmlnaHQKICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnRhaW5tZW50UmVjdCA9IHsKICAgICAgICAgICAgdG9wOiAwLAogICAgICAgICAgICBsZWZ0OiAwLAogICAgICAgICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LAogICAgICAgICAgICByaWdodDogd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoCiAgICAgICAgICB9OwogICAgICAgIH0KCiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgfHwge307CiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICBjb250YWlubWVudFJlY3QudG9wICs9IG9mZnNldC50b3AgfHwgMDsKICAgICAgICAgIGNvbnRhaW5tZW50UmVjdC5sZWZ0ICs9IG9mZnNldC5sZWZ0IHx8IDA7CiAgICAgICAgICBjb250YWlubWVudFJlY3QuYm90dG9tIC09IG9mZnNldC5ib3R0b20gfHwgMDsKICAgICAgICAgIGNvbnRhaW5tZW50UmVjdC5yaWdodCAtPSBvZmZzZXQucmlnaHQgfHwgMDsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHZpc2liaWxpdHlSZWN0ID0gewogICAgICAgICAgdG9wOiByZWN0LnRvcCA+PSBjb250YWlubWVudFJlY3QudG9wLAogICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ID49IGNvbnRhaW5tZW50UmVjdC5sZWZ0LAogICAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSA8PSBjb250YWlubWVudFJlY3QuYm90dG9tLAogICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgPD0gY29udGFpbm1lbnRSZWN0LnJpZ2h0CiAgICAgICAgfTsKCiAgICAgICAgY29uc3QgaGFzU2l6ZSA9IHJlY3QuaGVpZ2h0ID4gMCAmJiByZWN0LndpZHRoID4gMDsKCiAgICAgICAgbGV0IGlzVmlzaWJsZSA9CiAgICAgICAgICBoYXNTaXplICYmCiAgICAgICAgICB2aXNpYmlsaXR5UmVjdC50b3AgJiYKICAgICAgICAgIHZpc2liaWxpdHlSZWN0LmxlZnQgJiYKICAgICAgICAgIHZpc2liaWxpdHlSZWN0LmJvdHRvbSAmJgogICAgICAgICAgdmlzaWJpbGl0eVJlY3QucmlnaHQ7CgogICAgICAgIC8vIGNoZWNrIGZvciBwYXJ0aWFsIHZpc2liaWxpdHkKICAgICAgICBpZiAoaGFzU2l6ZSAmJiB0aGlzLnBhcnRpYWxWaXNpYmlsaXR5KSB7CiAgICAgICAgICBsZXQgcGFydGlhbFZpc2libGUgPQogICAgICAgICAgICByZWN0LnRvcCA8PSBjb250YWlubWVudFJlY3QuYm90dG9tICYmCiAgICAgICAgICAgIHJlY3QuYm90dG9tID49IGNvbnRhaW5tZW50UmVjdC50b3AgJiYKICAgICAgICAgICAgcmVjdC5sZWZ0IDw9IGNvbnRhaW5tZW50UmVjdC5yaWdodCAmJgogICAgICAgICAgICByZWN0LnJpZ2h0ID49IGNvbnRhaW5tZW50UmVjdC5sZWZ0OwoKICAgICAgICAgIC8vIGFjY291bnQgZm9yIHBhcnRpYWwgdmlzaWJpbGl0eSBvbiBhIHNpbmdsZSBlZGdlCiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFydGlhbFZpc2liaWxpdHkgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgIHBhcnRpYWxWaXNpYmxlID0gdmlzaWJpbGl0eVJlY3RbdGhpcy5wYXJ0aWFsVmlzaWJpbGl0eV07CiAgICAgICAgICB9CgogICAgICAgICAgLy8gaWYgd2UgaGF2ZSBtaW5pbXVtIHRvcCB2aXNpYmlsaXR5IHNldCBieSBwcm9wcywgbGV0cyBjaGVjaywgaWYgaXQgbWVldHMgdGhlIHBhc3NlZCB2YWx1ZQogICAgICAgICAgLy8gc28gaWYgZm9yIGluc3RhbmNlIGVsZW1lbnQgaXMgYXQgbGVhc3QgMjAwcHggaW4gdmlld3BvcnQsIHRoZW4gc2hvdyBpdC4KICAgICAgICAgIGlzVmlzaWJsZSA9IHRoaXMubWluVG9wVmFsdWUKICAgICAgICAgICAgPyBwYXJ0aWFsVmlzaWJsZSAmJgogICAgICAgICAgICByZWN0LnRvcCA8PSBjb250YWlubWVudFJlY3QuYm90dG9tIC0gdGhpcy5taW5Ub3BWYWx1ZQogICAgICAgICAgICA6IHBhcnRpYWxWaXNpYmxlOwogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICE9PSBpc1Zpc2libGUpIHsKICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gaXNWaXNpYmxlOwogICAgICAgICAgdGhpcy52aXNpYmlsaXR5UmVjdCA9IHZpc2liaWxpdHlSZWN0OwogICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgaXNWaXNpYmxlKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICByZW5kZXIoY3JlYXRlRWxlbWVudCwgY29udGV4dCkgewogICAgICByZXR1cm4gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IHN0eWxlOiAnaGVpZ2h0OiAxcHg7IHdpZHRoOiAxMDAlOycgfSk7CiAgICB9LAogIH07Cg=="},{"version":3,"sources":["visibility-sensor.vue"],"names":[],"mappings":";AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"visibility-sensor.vue","sourceRoot":"node_modules/vue-visibility-sensor","sourcesContent":["<script>\n  'use strict';\n\n  /**\n   * @param {{ top: Number, left: Number, bottom: Number, right: Number, width: Number, height: Number }} rect\n   * @returns {{ top: Number, left: Number, bottom: Number, right: Number, width: Number, height: Number }}\n   * */\n  function normalizeRect (rect) {\n    if (rect.width === undefined) {\n      rect.width = rect.right - rect.left;\n    }\n\n    if (rect.height === undefined) {\n      rect.height = rect.bottom - rect.top;\n    }\n\n    return rect;\n  }\n\n  /**\n   * @param {{ top: Number, left: Number, bottom: Number, right: Number }} rect\n   * @returns {{ top: Number, left: Number, bottom: Number, right: Number }}\n   * */\n  function roundRectDown (rect) {\n    return {\n      top: Math.floor(rect.top),\n      left: Math.floor(rect.left),\n      bottom: Math.floor(rect.bottom),\n      right: Math.floor(rect.right)\n    };\n  }\n\n  export default {\n    name: 'VisibilitySensor',\n    props: {\n      active: {\n        type: Boolean,\n        default: true\n      },\n      partialVisibility: {\n        type: [Boolean, String],\n        default: false,\n        validator: function (v) {\n          if (typeof v === 'boolean') {\n            return true;\n          } else {\n            return ['top', 'right', 'bottom', 'left'].indexOf(v) > -1;\n          }\n        }\n      },\n      minTopValue: {\n        type: Number,\n        default: 0\n      },\n      scrollCheck: {\n        type: Boolean,\n        default: false\n      },\n      scrollDelay: {\n        type: Number,\n        default: 250\n      },\n      scrollThrottle: {\n        type: Number,\n        default: -1\n      },\n      resizeCheck: {\n        type: Boolean,\n        default: false\n      },\n      resizeDelay: {\n        type: Number,\n        default: 250\n      },\n      resizeThrottle: {\n        type: Number,\n        default: -1\n      },\n      intervalCheck: {\n        type: Boolean,\n        default: true\n      },\n      intervalDelay: {\n        type: Number,\n        default: 100\n      },\n      delayedCall: {\n        type: Boolean,\n        default: false\n      },\n      offset: {\n        type: Object,\n        default: () => {\n        }\n        // should be\n        // {\n        //   top: Number,\n        //   left: Number,\n        //   right: Number,\n        //   bottom: Number,\n        // }\n      },\n      containment: {\n        default: null\n      }\n    },\n    data () {\n      return {\n        isVisible: null,\n        visibilityRect: {}\n      };\n    },\n    mounted () {\n      if (this.active) {\n        this.startWatching();\n      }\n    },\n    updated () {\n\n    },\n    beforeDestroy () {\n      this.stopWatching();\n    },\n    methods: {\n      getContainer () {\n        return this.containment || window;\n      },\n      addEventListener (target, event, delay, throttle) {\n        if (!this.debounceCheck) {\n          this.debounceCheck = {};\n        }\n        let timeout;\n        let fn;\n        const later = () => {\n          timeout = null;\n          this.check();\n        };\n\n        if (throttle > -1) {\n          fn = () => {\n            if (!timeout) {\n              timeout = setTimeout(later, throttle || 0);\n            }\n          };\n        } else {\n          fn = () => {\n            clearTimeout(timeout);\n            timeout = setTimeout(later, delay || 0);\n          };\n        }\n\n        const info = {\n          target,\n          fn,\n          getLastTimeout: () => timeout\n        };\n\n        target.addEventListener(event, info.fn);\n        this.debounceCheck[event] = info;\n      },\n      startWatching () {\n        if (this.debounceCheck || this.interval) {\n          return;\n        }\n\n        if (this.intervalCheck) {\n          this.interval = setInterval(() => this.check(), this.intervalDelay);\n        }\n\n        if (this.scrollCheck) {\n          this.addEventListener(\n            this.getContainer(),\n            'scroll',\n            this.scrollDelay,\n            this.scrollThrottle\n          );\n        }\n\n        if (this.resizeCheck) {\n          this.addEventListener(\n            window,\n            'resize',\n            this.resizeDelay,\n            this.resizeThrottle\n          );\n        }\n\n        !this.delayedCall && this.check();\n      },\n      stopWatching () {\n        if (this.debounceCheck) {\n          // clean up event listeners and their debounce callers\n          for (let debounceEvent in this.debounceCheck) {\n            if (this.debounceCheck.hasOwnProperty(debounceEvent)) {\n              const debounceInfo = this.debounceCheck[debounceEvent];\n\n              clearTimeout(debounceInfo.getLastTimeout());\n              debounceInfo.target.removeEventListener(\n                debounceEvent,\n                debounceInfo.fn\n              );\n\n              this.debounceCheck[debounceEvent] = null;\n            }\n          }\n        }\n        this.debounceCheck = null;\n\n        if (this.interval) {\n          clearInterval(this.interval);\n          this.interval = null;\n        }\n      },\n      check () {\n        const el = this.$el;\n        let rect;\n        let containmentRect;\n\n        if (!el) {\n          return;\n        }\n\n        rect = normalizeRect(roundRectDown(el.getBoundingClientRect()));\n\n        if (this.containment) {\n          const containmentDOMRect = this.containment.getBoundingClientRect();\n          containmentRect = {\n            top: containmentDOMRect.top,\n            left: containmentDOMRect.left,\n            bottom: containmentDOMRect.bottom,\n            right: containmentDOMRect.right\n          };\n        } else {\n          containmentRect = {\n            top: 0,\n            left: 0,\n            bottom: window.innerHeight || document.documentElement.clientHeight,\n            right: window.innerWidth || document.documentElement.clientWidth\n          };\n        }\n\n        const offset = this.offset || {};\n        if (typeof offset === 'object') {\n          containmentRect.top += offset.top || 0;\n          containmentRect.left += offset.left || 0;\n          containmentRect.bottom -= offset.bottom || 0;\n          containmentRect.right -= offset.right || 0;\n        }\n\n        const visibilityRect = {\n          top: rect.top >= containmentRect.top,\n          left: rect.left >= containmentRect.left,\n          bottom: rect.bottom <= containmentRect.bottom,\n          right: rect.right <= containmentRect.right\n        };\n\n        const hasSize = rect.height > 0 && rect.width > 0;\n\n        let isVisible =\n          hasSize &&\n          visibilityRect.top &&\n          visibilityRect.left &&\n          visibilityRect.bottom &&\n          visibilityRect.right;\n\n        // check for partial visibility\n        if (hasSize && this.partialVisibility) {\n          let partialVisible =\n            rect.top <= containmentRect.bottom &&\n            rect.bottom >= containmentRect.top &&\n            rect.left <= containmentRect.right &&\n            rect.right >= containmentRect.left;\n\n          // account for partial visibility on a single edge\n          if (typeof this.partialVisibility === 'string') {\n            partialVisible = visibilityRect[this.partialVisibility];\n          }\n\n          // if we have minimum top visibility set by props, lets check, if it meets the passed value\n          // so if for instance element is at least 200px in viewport, then show it.\n          isVisible = this.minTopValue\n            ? partialVisible &&\n            rect.top <= containmentRect.bottom - this.minTopValue\n            : partialVisible;\n        }\n\n        if (this.isVisible !== isVisible) {\n          this.isVisible = isVisible;\n          this.visibilityRect = visibilityRect;\n          this.$emit('change', isVisible);\n        }\n      }\n    },\n    render(createElement, context) {\n      return this.$slots.default || createElement('div', { style: 'height: 1px; width: 100%;' });\n    },\n  };\n</script>\n"]}]}